//
// Test case for COASM register allocation
//
.version 6.3
.target sm_50
.address_size 64

.visible .entry test_reg_alloc(.param .u64 param_a, .param .u64 param_b, .param .u32 param_c) {
    .reg .u64   %rd<5>;  // %rd1, %rd2, %rd3, %rd4
    .reg .u32   %r<8>;   // %r1, %r2, ..., %r7
    .reg .f32   %f<4>;   // %f1, %f2, %f3
    .reg .pred  %p<2>;   // %p1

    // Load parameters (handled by metadata)
    ld.param.u64    %rd1, [param_a];
    ld.param.u64    %rd2, [param_b];
    ld.param.u32    %r1, [param_c];

    // Use registers
    mov.u32     %r2, %r1;        // Use %r2 (should get %v0 or %v1)
    mov.f32     %f1, %r2;        // Use %f1 (should get %v2 or next available)
    add.u32     %r3, %r1, %r2;   // Use %r3 (should get next available)
    add.f32     %f2, %f1, %r3;   // Use %f2 (should get next available)

    // Use 64-bit registers
    mov.u64     %rd3, %rd1;      // Use %rd3 (should get %vd0, %vd2, %vd4, or next even %vd#)
    add.u64     %rd4, %rd1, %rd3; // Use %rd4 (should get next available even %vd#)

    // Mixed usage
    mov.u32     %r4, %rd4;       // Use low part of %rd4 as u32? (Conceptual, depends on COASM)
    mov.f32     %f3, %r4;        // Use %f3

    ret;
}
