// src/PtxTranslator.cpp
#include "PtxTranslator.h"
#include <iostream>
#include <sstream>
#include <algorithm>
#include <cctype>
#include <cassert>
#include <unordered_set>
#include <unordered_map>
#include <map>
#include <vector>
#include <memory>
#include <cstdint>
#include <fstream>
#include <filesystem> // C++17, for path operations if needed


// --- Include coasm_infra generated parser headers for validation (if available) ---
#if defined(COASM_INFRA_FOUND) && COASM_INFRA_FOUND
#include "coasmLexer.h" // From coasm_infra's generated ANTLR output
#include "coasmParser.h" // From coasm_infra's generated ANTLR output
#include "antlr4-runtime.h"
#endif

// --- Constructor and Main Entry ---
PtxTranslator::PtxTranslator(ptxParser::AstContext* tree, std::ofstream& out, const std::string& outFilename)
    : astContext(tree), outputFile(out), outputFilename(outFilename),
      nextCoasmVReg(1), nextCoasmVdReg(0) // Initialize register allocators
      {}



void PtxTranslator::translate() {
    if (astContext) {
        visitAst(astContext);
    }
    outputFile.flush();

    // --- NEW: Validate generated COASM output using coasm_infra parser ---
#if defined(COASM_INFRA_FOUND) && COASM_INFRA_FOUND
    std::cout << "Attempting to validate generated COASM code using coasm_infra parser...\n";
    // Read the generated file back into a string
    std::ifstream inFile(outputFilename);
    if (inFile.is_open()) {
        std::stringstream buffer;
        buffer << inFile.rdbuf();
        std::string generatedCoasmCode = buffer.str();
        inFile.close();

        if (!generatedCoasmCode.empty()) {
            if (validateOutputWithCoasmInfraParser(generatedCoasmCode)) {
                std::cout << "Validation Info: COASM code generated by ptxasm appears syntactically correct according to coasm_infra parser.\n";
            } else {
                std::cerr << "Validation Warning: COASM code generated by ptxasm may have syntax errors according to coasm_infra parser.\n";
                // Note: Don't exit on validation failure, as translation itself might have succeeded.
            }
        } else {
            std::cerr << "Validation Warning: Generated COASM file is empty. Skipping validation.\n";
        }
    } else {
        std::cerr << "Validation Error: Could not reopen output file " << outputFilename << " for validation.\n";
    }
#else
    std::cout << "Info: coasm_infra not found or disabled. Skipping COASM output validation.\n";
#endif
}

// --- Helper Functions (Implement based on previous discussions) ---
// These remain the same as before and are crucial for the macro-generated functions.
std::string PtxTranslator::getOperandText(ptxParser::OperandContext* operandCtx) {
    if (!operandCtx) return "";
    if (operandCtx->imm()) {
        return operandCtx->imm()->getText();
    } else if (operandCtx->var()) {
        return operandCtx->var()->getText();
    } else if (operandCtx->reg()) {
        return operandCtx->reg()->getText();
    } else if (operandCtx->vector()) {
        return operandCtx->getText();
    } else if (operandCtx->fetchAddress()) {
        return operandCtx->getText(); // Simplified
    }
    return operandCtx->getText();
}

std::string PtxTranslator::translateQualifierToSuffix(ptxParser::QualifierContext* qualifierCtx) {
    if (!qualifierCtx || !qualifierCtx->getStart()) return "";
    std::string text = qualifierCtx->getStart()->getText();
    std::transform(text.begin(), text.end(), text.begin(), ::tolower);
    if (!text.empty() && text[0] == '.') {
        text = text.substr(1);
    }
    if (text == "u8" || text == "u16" || text == "u32" || text == "u64" ||
        text == "s8" || text == "s16" || text == "s32" || text == "s64" ||
        text == "f16" || text == "f32" || text == "f64" ||
        text == "b8" || text == "b16" || text == "b32" || text == "b64" ||
        text == "pred") {
        return text;
    }
    return "";
}

std::string PtxTranslator::translateQualifiersToSuffix(const std::vector<ptxParser::QualifierContext*>& qualifiers) {
    for (auto* q : qualifiers) {
        std::string suffix = translateQualifierToSuffix(q);
        if (!suffix.empty()) {
            return suffix;
        }
    }
    return "u32";
}

// --- MAY NEED UPDATE: mapPtxOperandToCoasm (if it does more than just register mapping) ---
// The core logic for operand mapping likely remains, but now it uses the updated allocator.
std::string PtxTranslator::mapPtxOperandToCoasm(const std::string& ptxOperandText) {
    // 1. Check for register renaming/mapping first (NEW LOGIC)
    auto it = ptxToCoasmRegMap.find(ptxOperandText);
    if (it != ptxToCoasmRegMap.end()) {
        // std::cout << "Debug: Remapping " << ptxOperandText << " to " << it->second << std::endl;
        return it->second;
    }

    // 2. If it looks like a register but wasn't mapped, allocate it now (On-demand allocation)
    // This handles registers not declared in .reg or used directly.
    if (!ptxOperandText.empty() && ptxOperandText[0] == '%') {
        // Check if it's a standard register format (contains a digit after letters)
        if (ptxOperandText.find_first_of("0123456789", 1) != std::string::npos) {
             // Likely a register, allocate
             return allocateCoasmRegForPtx(ptxOperandText);
        }
    }

    // 3. Check for and record special register usage (unchanged)
    recordSpecialRegisterUsage(ptxOperandText);

    // 4. Default: return the operand as is (for immediates, unmapped regs, labels)
    return ptxOperandText;
}   
void PtxTranslator::recordSpecialRegisterUsage(const std::string& specialRegName) {
    if (!specialRegName.empty() && specialRegName[0] == '%' && specialRegName.find('.') != std::string::npos) {
        usedSpecialRegs.insert(specialRegName);
    }
}

uint32_t PtxTranslator::calculateKernelCtrl() {
    const std::unordered_map<std::string, uint32_t> CTRL_BITS = {
        {"%tid.x", 1U << 0}, {"%tid.y", 1U << 1}, {"%tid.z", 1U << 2},
        {"%ntid.x", 1U << 3}, {"%ntid.y", 1U << 4}, {"%ntid.z", 1U << 5},
        {"%ctaid.x", 1U << 6}, {"%ctaid.y", 1U << 7}, {"%ctaid.z", 1U << 8},
        {"%nctaid.x", 1U << 9}, {"%nctaid.y", 1U << 10}, {"%nctaid.z", 1U << 11},
    };
    uint32_t ctrl = 0;
    for (const auto& reg : usedSpecialRegs) {
        auto it = CTRL_BITS.find(reg);
        if (it != CTRL_BITS.end()) {
            ctrl |= it->second;
        }
    }
    return ctrl;
}

// --- COASM 寄存器分配辅助函数 ---

void PtxTranslator::initializeCoasmRegAllocation() {
    // Reset allocation state for the current kernel
    ptxToCoasmRegMap.clear();
    usedVRegsByVd.clear(); // Clear the set of vregs used by %vd
    nextCoasmVReg = 0;     // Start allocating %v from 0
    nextCoasmVdReg = 0;    // Start allocating %vd from 0 (even)
    // std::cout << "Debug: Initialized COASM register allocation for kernel '" << currentKernelName << "'." << std::endl;
    // std::cout << "       nextCoasmVReg: " << nextCoasmVReg << std::endl;
    // std::cout << "       nextCoasmVdReg (even): " << nextCoasmVdReg << std::endl;
}

std::string PtxTranslator::allocateCoasmRegForPtx(const std::string& ptxRegName) {
    if (ptxRegName.empty() || ptxRegName[0] != '%') {
        return ptxRegName; // Not a register
    }

    // 1. Check if already allocated
    auto it = ptxToCoasmRegMap.find(ptxRegName);
    if (it != ptxToCoasmRegMap.end()) {
        // std::cout << "Debug: Reusing COASM reg " << it->second << " for PTX reg " << ptxRegName << std::endl;
        return it->second;
    }

    // 2. Determine PTX register type prefix (e.g., "r", "f", "rd")
    std::string ptxTypePrefix;
    size_t numStart = 1;
    while(numStart < ptxRegName.size() && std::isalpha(ptxRegName[numStart])) {
        numStart++;
    }
    if (numStart > 1) {
         ptxTypePrefix = ptxRegName.substr(1, numStart - 1);
    } else {
        return ptxRegName; // Malformed or special reg? Return as is.
    }

    std::string coasmRegName;
    if (ptxTypePrefix == "r" || ptxTypePrefix == "f") {
        // 3a. Map %r or %f to %v#
        // Find the next available %v# that is NOT used by a %vd#
        while (usedVRegsByVd.find(nextCoasmVReg) != usedVRegsByVd.end()) {
            nextCoasmVReg++;
        }
        int coasmVNum = nextCoasmVReg;
        nextCoasmVReg++; // Advance for next allocation
        coasmRegName = "%v" + std::to_string(coasmVNum);
     } else if (ptxTypePrefix == "rd") {
        // 3b. Map %rd to %vd# (even number)
        // Find the next available even %vd# such that %vdN and %vd(N+1) are not used by other %vd allocations
        // We need to ensure %vN and %v(N+1) are free.
        while (usedVRegsByVd.find(nextCoasmVdReg) != usedVRegsByVd.end() ||
               usedVRegsByVd.find(nextCoasmVdReg + 1) != usedVRegsByVd.end()) {
            nextCoasmVdReg += 2; // Increment by 2 to ensure even numbers and check pairs
        }
        int coasmVdNum = nextCoasmVdReg;
        nextCoasmVdReg += 2; // Advance by 2 for next %vd allocation

        // 4. Record the %v# registers used by this %vd#
        usedVRegsByVd.insert(coasmVdNum);       // Mark %vN as used
        usedVRegsByVd.insert(coasmVdNum + 1);   // Mark %v(N+1) as used

        coasmRegName = "%vd" + std::to_string(coasmVdNum);
    } else {
        // 5. Handle %p or other types, or return original
        if (ptxTypePrefix == "p") {
             // Find next available %p number (needs tracking)
             static int nextP = 0; // Simplified, should be per-kernel
             coasmRegName = "%p" + std::to_string(nextP++);
        } else {
            return ptxRegName; // Unknown type, pass through
        }
    }

    // 6. Store the mapping
    ptxToCoasmRegMap[ptxRegName] = coasmRegName;
    // std::cout << "Debug: Allocated COASM reg " << coasmRegName << " for PTX reg " << ptxRegName << std::endl;
    return coasmRegName;
}
// --- Visitor Implementations ---
antlrcpp::Any PtxTranslator::visitAst(ptxParser::AstContext *context) {
    return visitChildren(context);
}

antlrcpp::Any PtxTranslator::visitKernels(ptxParser::KernelsContext *context) {
    return visitChildren(context);
}

// --- MODIFIED visitKernel ---
antlrcpp::Any PtxTranslator::visitKernel(ptxParser::KernelContext *context) {
    if (!context->ID()) return nullptr;
    currentKernelName = context->ID()->getText();
    currentKernelMetadata = std::make_unique<KernelMetadata>();
    currentKernelMetadata->name = currentKernelName;
    ptxParamToCoasmReg.clear();
    ptxSharedToCoasmReg.clear();
    usedSpecialRegs.clear();
    ptxRegCounts.clear();
    ptxMaxRegNumbers.clear();
    ptxToCoasmRegMap.clear();

    // This is the crucial step that uses the data gathered above.
    initializeCoasmRegAllocation(); // This sets up nextCoasmVReg/nextCoasmVdReg correctly
 
    emitKernelHeader();

    // Visit parameters first to build the mapping (if needed for metadata)
    if (context->params()) {
        visitChildren(context->params());
    }

    // Visit reg statements
    /*
    if (context->compoundStatement() && context->compoundStatement()->statements()) {
         visitChildren(context->compoundStatement());
    }
    */

    // Visit statements for translation
    if (context->compoundStatement()) {
        visitCompoundStatement(context->compoundStatement()); // This does the actual translation
    }

    currentKernelMetadata->kernel_ctrl = calculateKernelCtrl();
    emitKernelFooter();
    currentKernelMetadata.reset();
    return nullptr;
}

antlrcpp::Any PtxTranslator::visitParam(ptxParser::ParamContext *context) {
     if (context->ID()) {
        std::string ptxParamName = context->ID()->getText();

        std::map<std::string, std::string> argInfo;
        argInfo[".address_space"] = "global";
        argInfo[".name"] = ptxParamName;
        argInfo[".offset"] = "0";
        argInfo[".size"] = "8";
        argInfo[".value_kind"] = "global_buffer";
        currentKernelMetadata->args.push_back(argInfo);
    }
    return nullptr;
}

antlrcpp::Any PtxTranslator::visitStatements(ptxParser::StatementsContext *context) {
    return visitChildren(context);
}

antlrcpp::Any PtxTranslator::visitStatement(ptxParser::StatementContext *context) {
    return visitChildren(context); // Dispatches to specific statement visitors
}

antlrcpp::Any PtxTranslator::visitCompoundStatement(ptxParser::CompoundStatementContext *context) {
    if (context->statements()) {
        return visitStatements(context->statements());
    }
    return nullptr;
}

antlrcpp::Any PtxTranslator::visitRegStatement(ptxParser::RegStatementContext *context) {
    // .reg .u64 %rd<5>; or .reg .u32 %r<8>; or .reg .f32 %f<4>;
    // 或者 .reg .u32 %r1; (单个寄存器声明 - 不常见，但语法允许)

    // 1. 获取 reg 规则上下文
    ptxParser::RegContext* regCtx = context->reg();
    if (!regCtx) {
        return nullptr; // 如果没有 reg 部分，无法处理
    }

    // 2. 从 reg 中获取 ID 列表 (通常是寄存器类型前缀，如 "r", "f", "rd")
    // reg 规则: PERCENT ID (DOT ID)* ;
    // 例如: %r1, %f2, %rd3, %tid.x
    std::vector<antlr4::tree::TerminalNode*> idNodes = regCtx->ID();
    if (idNodes.empty()) {
        std::cerr << "Warning: Malformed .reg declaration, no ID found in reg part.\n";
        return nullptr;
    }
    std::string regPrefix = idNodes[0]->getText(); // 获取第一个 ID，通常是类型前缀 ("r", "f", "rd")

    // 3. 检查是否是向量声明 (<count> 部分)
    if (context->DIGITS()) {
        // Case: .reg .u32 %r<8>;
        std::string countStr = context->DIGITS()->getText();
        try {
            int count = std::stoi(countStr);
            // 更新最大 *计数* 用于该前缀 (这是声明的数量)
            if (ptxRegCounts[regPrefix] < count) {
                ptxRegCounts[regPrefix] = count;
            }
            // 也更新最大 *编号* 如果计数暗示了更高的编号
            // 如果是 %r<count>，最高编号是 count。
            if (ptxMaxRegNumbers[regPrefix] < count) {
                 ptxMaxRegNumbers[regPrefix] = count;
            }
            // std::cout << "Debug: Processed .reg " << regPrefix << "<" << count << ">" << std::endl;
        } catch (const std::exception& e) {
            std::cerr << "Warning: Could not parse register count '" << countStr << "' for prefix '" << regPrefix << "': " << e.what() << std::endl;
        }
    } else {
        // Case: .reg .u32 %r1; (单个寄存器) 或 .reg .u32 %tid.x;
        // 我们需要从完整的 reg 文本中提取编号（如果适用）。
        // 这对于单个寄存器声明来说更复杂，因为我们不知道确切的编号。
        // 一种简单方法是假设如果只有一个 ID ("r")，它可能代表一个编号范围。
        // 或者，我们可以只处理向量声明，因为单个声明通常由寄存器重命名逻辑处理。
        // 为了简化，我们暂时只关注向量声明部分。单个寄存器将在使用时按需分配。
        // std::cout << "Debug: Encountered single .reg declaration for prefix '" << regPrefix << "'. Handled by on-demand allocation." << std::endl;
    }

    return nullptr; // .reg 语句本身不生成 COASM 输出
}

// --- Special Instruction Translations (Manual, as before) ---
antlrcpp::Any PtxTranslator::visitLdStatement(ptxParser::LdStatementContext *context) {
    bool isParamLoad = false;
    // --- 检查是否是 ld.param ---
    for (auto* qual : context->qualifier()) {
        // --- 确保 qual 和其起始 token 存在 ---
        if (qual && qual->getStart()) {
            // --- 检查 qualifier token 的类型是否是 PARAM (来自 ptxLexer) ---
            if (qual->getStart()->getType() == ptxLexer::PARAM) {
                isParamLoad = true;
                break;
            }
        }
    }

    if (isParamLoad) {
        // --- 处理 ld.param (保持不变或按之前讨论修改) ---
        // ld.param.u64 %rd1, [_Z9vectorAddPfS_S_i_param_0];
        if (context->operandTwo() && context->operandTwo()->operand().size() >= 2) {
            auto* destOpCtx = context->operandTwo()->operand(0); // %rd1
            auto* srcOpCtx = context->operandTwo()->operand(1); // [_Z9vectorAddPfS_S_i_param_0]

            std::string ptxDestReg = getOperandText(destOpCtx); // e.g., "%rd1"
            std::string ptxParamName; // e.g., "_Z9vectorAddPfS_S_i_param_0"

            // 提取参数名称 (symbolic name) 从 fetchAddress 操作数
            if (srcOpCtx && srcOpCtx->fetchAddress()) {
                ptxParser::FetchAddressContext* faCtx = srcOpCtx->fetchAddress();
                // 根据语法: fetchAddress : LeftBracket (ID|regi) PLUS? DIGITS? RightBracket ;
                // 直接检查 ID 或 regi
                if (faCtx->ID()) {
                    // 最常见的情况：参数名是标识符，如 _Z9vectorAddPfS_S_i_param_0
                    ptxParamName = faCtx->ID()->getText();
                } else if (faCtx->regi()) {
                    // 较少见：参数地址存储在寄存器中，如 %ctaid.x
                    // 这种情况下，ptxParamName 会是寄存器名，这可能不是我们想要的符号名
                    // 但对于 ld.param 来说，ID() 通常是正确的来源
                    std::cerr << "Warning: ld.param source operand fetchAddress contains regi but no ID. This might be unusual." << std::endl;
                    ptxParamName = faCtx->regi()->getText(); // Fallback
                }
                // 注意：PLUS 和 DIGITS 是用于地址计算的，如 [base + offset]
                // 对于简单的参数加载 [param_name]，它们是不存在的。
                // 如果存在，提取逻辑会更复杂，需要处理偏移量。
            }

            if (!ptxDestReg.empty() && !ptxParamName.empty()) {
                // --- NEW LOGIC FOR ld.param ---
                // 1. 为目的地分配一个新的 COASM 寄存器，基于 PTX 目的地寄存器的类型
                std::string newCoasmDestReg = allocateCoasmRegForPtx(ptxDestReg); // e.g., "%vd6" if ptxDestReg was "%rd1"
                // 映射 ptxDestReg -> newCoasmDestReg 已经存储在 allocateCoasmRegForPtx 内部的 ptxToCoasmRegMap 中

                // 2. 生成 COASM ld.param 指令，使用 %s0 作为基址
                std::string typeSuffix = translateQualifiersToSuffix(context->qualifier());
                // 输出: ld.param.<type> <new_coasm_reg>, [%s0 + <param_name>]
                outputFile << "\tld.param." << typeSuffix << "\t" << newCoasmDestReg << ", [%s0 + " << ptxParamName << "]\n";

                // 3. 记录从原始 PTX 目的地寄存器到新 COASM 寄存器的映射
                // 这已经在 allocateCoasmRegForPtx 中完成并通过 ptxToCoasmRegMap 存储
                // 因此，后续对 %rd1 的使用将通过 mapPtxOperandToCoasm 映射到 %vd6

                return nullptr; // 已处理 ld.param
            } else {
                std::cerr << "Warning: Could not extract dest reg or param name from ld.param instruction." << std::endl;
                if (ptxDestReg.empty()) std::cerr << "  -> Dest reg text was empty." << std::endl;
                if (ptxParamName.empty()) {
                     std::cerr << "  -> Param name text was empty." << std::endl;
                     // 调试：打印源操作数的文本以供检查
                     if (srcOpCtx) {
                         std::cerr << "  -> Source operand text: " << getOperandText(srcOpCtx) << std::endl;
                     }
                }
            }
        }
        // 如果提取失败，则继续？或者返回错误？
    } else {
        // --- 处理非 ld.param 指令 (例如 ld.global, ld.shared) ---
        // ld.global.f32 %f1, [%rd1 + %r1 * 4];
        if (context->operandTwo() && context->operandTwo()->operand().size() >= 2) {
             auto* destOpCtx = context->operandTwo()->operand(0); // %f1
             auto* srcOpCtx = context->operandTwo()->operand(1); // [%rd1 + %r1 * 4]

             std::string ptxDestReg = getOperandText(destOpCtx); // %f1
             std::string ptxSrcAddr = getOperandText(srcOpCtx); // [%rd1 + %r1 * 4]

             // 1. 为目标寄存器分配 COASM 寄存器
             std::string coasmDestReg = mapPtxOperandToCoasm(ptxDestReg); // %f1 -> %v8

             // 2. 翻译源地址操作数
             // 这需要更复杂的逻辑来处理 [base + index * scale + offset]
             // 一个简化的方法是直接使用 mapPtxOperandToCoasm 处理整个地址字符串
             // 但这可能不够精确。更好的方法是解析 srcOpCtx->fetchAddress() 的结构。
             // 为了快速修复，我们先尝试直接映射地址字符串。
             // 注意：这可能无法完美处理复杂的地址表达式。
             std::string coasmSrcAddr = mapPtxOperandToCoasm(ptxSrcAddr); // [%rd1 + %r1 * 4] -> [%vd0 + %v6 * 4]

             // 3. 确定类型后缀
             std::string typeSuffix = translateQualifiersToSuffix(context->qualifier());

             // 4. 确定内存空间后缀 (ld.global, ld.shared, ld.local, ld.const)
             std::string spaceSuffix = "global"; // 默认
             for (auto* qual : context->qualifier()) {
                 if (qual && qual->getStart()) {
                     std::string qualText = qual->getStart()->getText();
                     std::transform(qualText.begin(), qualText.end(), qualText.begin(), ::tolower);
                     if (qualText == ".global") { spaceSuffix = "global"; break; }
                     else if (qualText == ".shared") { spaceSuffix = "shared"; break; }
                     else if (qualText == ".local") { spaceSuffix = "local"; break; }
                     else if (qualText == ".const") { spaceSuffix = "const"; break; }
                     // ... 其他空间 ...
                 }
             }

             // 5. 生成 COASM 指令
             // 假设 coasm 格式是 ld.<space>.<type> <dst>, <addr>
             outputFile << "\tld." << spaceSuffix << "." << typeSuffix << "\t" << coasmDestReg << ", " << coasmSrcAddr << "\n";
        }
        return nullptr; // 已处理非 ld.param
    }

    // 如果它不是我们识别的 param 加载，或者不匹配预期模式，
    // 它可能是一个错误或一个我们不处理的 ld 指令（尽管 ld.param 是主要的）
    std::cerr << "Warning: Encountered ld instruction that is not a recognized ld.param or has unexpected format. Treating as generic ld (not implemented)." << std::endl;
    return nullptr; // 或者实现对非 param ld 的翻译（如果需要）
}

antlrcpp::Any PtxTranslator::visitStStatement(ptxParser::StStatementContext *context) {
    // st.global.f32 [%rd3 + %r1 * 4], %f3;
    if (context->operandTwo() && context->operandTwo()->operand().size() >= 2) {
        auto* addrOpCtx = context->operandTwo()->operand(0); // [%rd3 + %r1 * 4]
        auto* srcOpCtx = context->operandTwo()->operand(1); // %f3

        std::string ptxAddrOperand = getOperandText(addrOpCtx); // [%rd3 + %r1 * 4]
        std::string ptxSrcOperand = getOperandText(srcOpCtx); // %f3

        // 1. 翻译地址操作数 (这应该应用寄存器映射，如 %rd3 -> %vd4)
        std::string coasmAddrOperand = mapPtxOperandToCoasm(ptxAddrOperand); // [%rd3 + ...] -> [%vd4 + ...]

        // 2. 翻译源操作数
        std::string coasmSrcOperand = mapPtxOperandToCoasm(ptxSrcOperand); // %f3 -> %v7

        // 3. 确定类型后缀和空间后缀 (与 visitLdStatement 类似)
        std::string typeSuffix = translateQualifiersToSuffix(context->qualifier());
        std::string spaceSuffix = "global"; // 默认
        for (auto* qual : context->qualifier()) {
             if (qual && qual->getStart()) {
                 std::string qualText = qual->getStart()->getText();
                 std::transform(qualText.begin(), qualText.end(), qualText.begin(), ::tolower);
                 if (qualText == ".global") { spaceSuffix = "global"; break; }
                 else if (qualText == ".shared") { spaceSuffix = "shared"; break; }
                 else if (qualText == ".local") { spaceSuffix = "local"; break; }
                 else if (qualText == ".const") { spaceSuffix = "const"; break; }
                 // ... 其他空间 ...
             }
        }

        // 4. 生成 COASM 指令
        // 假设 coasm 格式是 st.<space>.<type> <addr>, <src>
        outputFile << "\tst." << spaceSuffix << "." << typeSuffix << "\t" << coasmAddrOperand << ", " << coasmSrcOperand << "\n";
    }
    return nullptr;
}

antlrcpp::Any PtxTranslator::visitMovStatement(ptxParser::MovStatementContext *context) {
     if (context->operandTwo() && context->operandTwo()->operand().size() >= 2) {
        std::vector<ptxParser::QualifierContext*> tempQualifierVec;
        ptxParser::QualifierContext* singleQualifier = context->qualifier(); // Get single pointer
        if (singleQualifier) {
            tempQualifierVec.push_back(singleQualifier);
        }
        std::string typeSuffix = translateQualifiersToSuffix(tempQualifierVec);
        std::string dst = mapPtxOperandToCoasm(getOperandText(context->operandTwo()->operand(0)));
        std::string src = mapPtxOperandToCoasm(getOperandText(context->operandTwo()->operand(1)));
        outputFile << "\tmov." << typeSuffix << "\t" << dst << ", " << src << "\n";
    }
    return nullptr;
}
antlrcpp::Any PtxTranslator::visitSetpStatement(ptxParser::SetpStatementContext *context) {
    // setp.eq.u32 %p1, %r1, %r2;
    std::string cmpOp = "eq";
    for (auto* q : context->qualifier()) {
         if (q && q->getStart()) {
             std::string text = q->getStart()->getText();
             std::transform(text.begin(), text.end(), text.begin(), ::tolower);
             if (!text.empty() && text[0] == '.') text = text.substr(1);
             if (text == "eq" || text == "ne" || text == "lt" || text == "le" ||
                 text == "gt" || text == "ge" || text == "lo" || text == "ls" ||
                 text == "hi" || text == "hs" || text == "equ" || text == "neu" ||
                 text == "ltu" || text == "leu" || text == "gtu" || text == "geu") {
                 cmpOp = text;
                 break;
             }
         }
    }

    if (context->operandThree() && context->operandThree()->operand().size() >= 3) {
        std::string predDst = mapPtxOperandToCoasm(getOperandText(context->operandThree()->operand(0)));
        std::string src1 = mapPtxOperandToCoasm(getOperandText(context->operandThree()->operand(1)));
        std::string src2 = mapPtxOperandToCoasm(getOperandText(context->operandThree()->operand(2)));
        outputFile << "\tsetp." << cmpOp << ".u32\t" << predDst << ", " << src1 << ", " << src2 << "\n";
    }
    return nullptr;
}
antlrcpp::Any PtxTranslator::visitBraStatement(ptxParser::BraStatementContext *context) {
    // bra BB0_3; or @%p1 bra BB0_3;
    if (context->ID()) {
         std::string targetLabel = context->ID()->getText();
         // TODO: Handle predicate from context if present (e.g., check qualifiers for pred)
         outputFile << "\ts_branch " << targetLabel << "\n"; // Placeholder coasm branch
    }
    return nullptr;
}

antlrcpp::Any PtxTranslator::visitRetStatement(ptxParser::RetStatementContext *context) {
    outputFile << "\tt_exit\n";
    return nullptr;
}

antlrcpp::Any PtxTranslator::visitCvtStatement(ptxParser::CvtStatementContext *context) {
    // cvt.u32.f32 dst, src
    std::string toType = "u32";
    std::string fromType = "u32";
    int typeCount = 0;
    for (auto* q : context->qualifier()) {
        std::string suffix = translateQualifierToSuffix(q);
        if (!suffix.empty()) {
            if (typeCount == 0) toType = suffix;
            else if (typeCount == 1) { fromType = suffix; break; }
            typeCount++;
        }
    }

    if (context->operandTwo() && context->operandTwo()->operand().size() >= 2) {
        std::string dst = mapPtxOperandToCoasm(getOperandText(context->operandTwo()->operand(0)));
        std::string src = mapPtxOperandToCoasm(getOperandText(context->operandTwo()->operand(1)));
        outputFile << "\tcvt." << toType << "." << fromType << "\t" << dst << ", " << src << "\n";
    }
    return nullptr;
}
antlrcpp::Any PtxTranslator::visitMadStatement(ptxParser::MadStatementContext *context) {
    // madStatement : MAD qualifier* operandFour SEMI ;
    if (context->operandFour() && context->operandFour()->operand().size() >= 4) {
        const std::vector<ptxParser::QualifierContext*>& qualifiers = context->qualifier();
        std::string typeSuffix = translateQualifiersToSuffix(qualifiers);
        std::string dst = mapPtxOperandToCoasm(getOperandText(context->operandFour()->operand(0)));
        std::string src1 = mapPtxOperandToCoasm(getOperandText(context->operandFour()->operand(1)));
        std::string src2 = mapPtxOperandToCoasm(getOperandText(context->operandFour()->operand(2)));
        std::string src3 = mapPtxOperandToCoasm(getOperandText(context->operandFour()->operand(3)));
        outputFile << "\tmad." << typeSuffix << "\t" << dst << ", " << src1 << ", " << src2 << ", " << src3 << "\n";
    }
    return nullptr;
}
antlrcpp::Any PtxTranslator::visitFmaStatement(ptxParser::FmaStatementContext *context) {
    // fma.rn.f32 d, a, b, c;
    if (context->operandFour() && context->operandFour()->operand().size() >= 4) {
        const std::vector<ptxParser::QualifierContext*>& qualifiers = context->qualifier();
        std::string typeSuffix = translateQualifiersToSuffix(qualifiers);
        std::string dst = mapPtxOperandToCoasm(getOperandText(context->operandFour()->operand(0)));
        std::string src1 = mapPtxOperandToCoasm(getOperandText(context->operandFour()->operand(1)));
        std::string src2 = mapPtxOperandToCoasm(getOperandText(context->operandFour()->operand(2)));
        std::string src3 = mapPtxOperandToCoasm(getOperandText(context->operandFour()->operand(3)));
        outputFile << "\tfma." << typeSuffix << "\t" << dst << ", " << src1 << ", " << src2 << ", " << src3 << "\n";
    }
    return nullptr;
}
antlrcpp::Any PtxTranslator::visitSelpStatement(ptxParser::SelpStatementContext *context) {
    // selp.a.type d, a, b, c;
    if (context->operandFour() && context->operandFour()->operand().size() >= 4) {
        const std::vector<ptxParser::QualifierContext*>& qualifiers = context->qualifier();
        std::string typeSuffix = translateQualifiersToSuffix(qualifiers);
        std::string dst = mapPtxOperandToCoasm(getOperandText(context->operandFour()->operand(0)));
        std::string src1 = mapPtxOperandToCoasm(getOperandText(context->operandFour()->operand(1)));
        std::string src2 = mapPtxOperandToCoasm(getOperandText(context->operandFour()->operand(2)));
        std::string pred = mapPtxOperandToCoasm(getOperandText(context->operandFour()->operand(3)));
        outputFile << "\tselp." << typeSuffix << "\t" << dst << ", " << src1 << ", " << src2 << ", " << pred << "\n";
    }
    return nullptr;
}

// --- Macros for Reducing Code Duplication ---

// --- Macro for Instructions using operandTwo (dst, src) ---
#define TRANSLATE_INSTR_2OP(OP_NAME_UPPER, PTX_CONTEXT_TYPE) \
antlrcpp::Any PtxTranslator::visit##PTX_CONTEXT_TYPE(ptxParser::PTX_CONTEXT_TYPE##Context *context) { \
    if (context->operandTwo() && context->operandTwo()->operand().size() >= 2) { \
        std::string typeSuffix = translateQualifiersToSuffix(context->qualifier()); \
        std::string dst = mapPtxOperandToCoasm(getOperandText(context->operandTwo()->operand(0))); \
        std::string src = mapPtxOperandToCoasm(getOperandText(context->operandTwo()->operand(1))); \
        outputFile << "\t" << OP_NAME_UPPER << "." << typeSuffix << "\t" << dst << ", " << src << "\n"; \
    } \
    return nullptr; \
}

// --- Macro for Instructions using operandThree (dst, src1, src2) ---
// mapPtxOperandToCoasm will now use the new allocation logic:
// %r1 -> %vX, %rd2 -> %vdY (where Y is even, and %vY, %v(Y+1) are marked used)
#define TRANSLATE_INSTR_3OP(OP_NAME_UPPER, PTX_CONTEXT_TYPE) \
antlrcpp::Any PtxTranslator::visit##PTX_CONTEXT_TYPE(ptxParser::PTX_CONTEXT_TYPE##Context *context) { \
    if (context->operandThree() && context->operandThree()->operand().size() >= 3) { \
        std::string typeSuffix = translateQualifiersToSuffix(context->qualifier()); \
        std::string dst = mapPtxOperandToCoasm(getOperandText(context->operandThree()->operand(0))); \
        std::string src1 = mapPtxOperandToCoasm(getOperandText(context->operandThree()->operand(1))); \
        std::string src2 = mapPtxOperandToCoasm(getOperandText(context->operandThree()->operand(2))); \
        outputFile << "\t" << OP_NAME_UPPER << "." << typeSuffix << "\t" << dst << ", " << src1 << ", " << src2 << "\n"; \
    } \
    return nullptr; \
}

// --- Macro for Instructions using operandFour (dst, src1, src2, src3) ---
#define TRANSLATE_INSTR_4OP(OP_NAME_UPPER, PTX_CONTEXT_TYPE) \
antlrcpp::Any PtxTranslator::visit##PTX_CONTEXT_TYPE(ptxParser::PTX_CONTEXT_TYPE##Context *context) { \
    if (context->operandFour() && context->operandFour()->operand().size() >= 4) { \
        std::string typeSuffix = translateQualifiersToSuffix(context->qualifier()); \
        std::string dst = mapPtxOperandToCoasm(getOperandText(context->operandFour()->operand(0))); \
        std::string src1 = mapPtxOperandToCoasm(getOperandText(context->operandFour()->operand(1))); \
        std::string src2 = mapPtxOperandToCoasm(getOperandText(context->operandFour()->operand(2))); \
        std::string src3 = mapPtxOperandToCoasm(getOperandText(context->operandFour()->operand(3))); \
        outputFile << "\t" << OP_NAME_UPPER << "." << typeSuffix << "\t" << dst << ", " << src1 << ", " << src2 << ", " << src3 << "\n"; \
    } \
    return nullptr; \
}

// --- Generate Visitor Functions using Macros ---

// --- Instructions using operandTwo (dst, src) ---
TRANSLATE_INSTR_3OP("add", AddStatement)
TRANSLATE_INSTR_3OP("mul", MulStatement)
TRANSLATE_INSTR_3OP("div", DivStatement)
TRANSLATE_INSTR_3OP("sub", SubStatement)
TRANSLATE_INSTR_3OP("shl", ShlStatement)
TRANSLATE_INSTR_3OP("shr", ShrStatement)
TRANSLATE_INSTR_3OP("max", MaxStatement)
TRANSLATE_INSTR_3OP("min", MinStatement)
TRANSLATE_INSTR_3OP("and", AndStatement)
TRANSLATE_INSTR_3OP("or", OrStatement)
TRANSLATE_INSTR_3OP("xor", XorStatement)
TRANSLATE_INSTR_2OP("neg", NegStatement)
TRANSLATE_INSTR_2OP("not", NotStatement)
TRANSLATE_INSTR_2OP("abs", AbsStatement)
TRANSLATE_INSTR_2OP("rcp", RcpStatement)
TRANSLATE_INSTR_2OP("sqrt", SqrtStatement)
TRANSLATE_INSTR_2OP("rsqrt", RsqrtStatement)
// Add more 2-op instructions as needed...

// --- Instructions using operandThree (dst, src1, src2) ---
// TRANSLATE_INSTR_3OP("mul", MulStatement) // Already handled by 2-op macro if it uses operandTwo
// Add more 3-op instructions as needed...

// --- Instructions using operandFour (dst, src1, src2, src3) ---
// TRANSLATE_INSTR_4OP("mad", MadStatement) // Already handled manually
// Add more 4-op instructions as needed...

// --- Output Generation (Implement based on previous discussions) ---
void PtxTranslator::emitKernelHeader() {
    outputFile << "\t.text\n";
    outputFile << "\t.global " << currentKernelName << "\n";
    outputFile << "\t.type " << currentKernelName << ",@function\n";
    outputFile << currentKernelName << ":\n";
    outputFile << "bb_00:\n";
}

void PtxTranslator::emitKernelFooter() {
    if (!currentKernelMetadata) return;
    outputFile << "-\n";
    outputFile << "opu.kernels:\n";
    outputFile << " - .name: " << currentKernelMetadata->name << "\n";
    outputFile << "   .args:\n";
    for (const auto& arg : currentKernelMetadata->args) {
        outputFile << "     -";
        for (const auto& pair : arg) {
            outputFile << " " << pair.first << ": " << pair.second;
        }
        outputFile << "\n";
    }
    outputFile << "   .shared_memsize: " << currentKernelMetadata->shared_memsize << "\n";
    outputFile << "   .private_memsize: " << currentKernelMetadata->private_memsize << "\n";
    outputFile << "   .cmem_size: " << currentKernelMetadata->cmem_size << "\n";
    outputFile << "   .bar_used: " << currentKernelMetadata->bar_used << "\n";
    outputFile << "   .local_framesize: " << currentKernelMetadata->local_framesize << "\n";
    outputFile << "   .kernel_ctrl: " << currentKernelMetadata->kernel_ctrl << "\n";
    outputFile << "   .kernel_mode: " << currentKernelMetadata->kernel_mode << "\n";
    outputFile << "opu.version:\n";
    outputFile << " - 2\n";
    outputFile << " - 0\n";
    outputFile << "...\n";
}

// --- Validation (NEW) ---
#if defined(COASM_INFRA_FOUND) && COASM_INFRA_FOUND
bool PtxTranslator::validateOutputWithCoasmInfraParser(const std::string& coasmCode) {
    if (coasmCode.empty()) {
        std::cerr << "Validation Error: Empty COASM code provided for validation.\n";
        return false;
    }

    try {
        antlr4::ANTLRInputStream input(coasmCode);
        coasmLexer lexer(&input); // Use coasm_infra's generated lexer
        antlr4::CommonTokenStream tokens(&lexer);
        coasmParser parser(&tokens); // Use coasm_infra's generated parser

        // Parse the entire input (assuming 'prog' is the start rule)
        coasmParser::ProgContext* tree = parser.prog();

        size_t numErrors = parser.getNumberOfSyntaxErrors();
        if (numErrors > 0) {
            std::cerr << "Validation Error: " << numErrors
                      << " syntax error(s) found in generated COASM code by coasm_infra parser.\n";
            // ANTLR usually prints errors to stderr already
            return false;
        } else {
            // std::cout << "Validation Info: No syntax errors detected by coasm_infra parser.\n";
            return true;
        }
    } catch (const std::exception& e) {
        std::cerr << "Validation Error: Exception occurred during coasm_infra parsing: " << e.what() << std::endl;
        return false;
    } catch (...) {
        std::cerr << "Validation Error: Unknown exception occurred during coasm_infra parsing." << std::endl;
        return false;
    }
}
#endif
